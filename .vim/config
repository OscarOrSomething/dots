" GENERAL
set number
set showbreak=+++   
set showmatch
set errorbells
set novisualbell
 
set hlsearch
set smartcase
set ignorecase
set incsearch

set ruler
 
set autochdir
set autowriteall
 
set undolevels=1000
set backspace=indent,eol,start

set wrap
set linebreak
set nolist

set nocompatible
filetype off

set autoindent

set noexpandtab
set tabstop=4
set shiftwidth=4

" Turn on syntax highlighting
syntax on

" Don't use arrow keys doofus.
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>

" Ctrl+S to save
noremap <silent> <C-S>          :update<CR>
vnoremap <silent> <C-S>         <C-C>:update<CR>
inoremap <silent> <C-S>         <C-O>:update<CR>

" VUNDLE

set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()

Plugin 'VundleVim/Vundle.vim'

Plugin 'scrooloose/nerdtree'
Plugin 'ctrlpvim/ctrlp.vim'
Plugin 'tpope/vim-fugitive'
Plugin 'jeffkreeftmeijer/vim-numbertoggle'

Plugin 'editorconfig/editorconfig-vim'
Plugin 'rust-lang/rust.vim'
Plugin 'scrooloose/nerdcommenter'
Plugin 'w0rp/ale'

Plugin 'dylanaraps/wal.vim'

call vundle#end()

" Get colour scheme from wal
colorscheme wal 

" Ctrl+P
let g:ctrlp_working_path_mode = 'ra'
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*/node_modules/*,*/.git/*     " MacOSX/Linux
let g:ctrlp_user_command = ['.git', 'cd %s && git ls-files -co --exclude-standard']

" NERDTree
map <C-n> :NERDTreeToggle<CR>
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

" Ale
let g:ale_fix_on_save = 1

let g:ale_linters = {'rust': ['rls'], 'python': ['pylint'], 'javascript': ['eslint']}

" Status line

let g:currentmode={ 'n' : 'n', 'no' : 'N·Operator Pending', 'v' : 'v', 'V' : 'V·Line', '^V' : 'V·Block', 's' : 'Select', 'S': 'S·Line', '^S' : 'S·Block', 'i' : 'i', 'R' : 'r', 'Rv' : 'V·Replace', 'c' : 'Command', 'cv' : 'Vim Ex', 'ce' : 'Ex', 'r' : 'Prompt', 'rm' : 'More', 'r?' : 'Confirm', '!' : 'Shell', 't' : 'Terminal'}

function! ModeCurrent() abort
    let l:modecurrent = mode()
    let l:modelist = toupper(get(g:currentmode, l:modecurrent, 'V·Block '))
    let l:current_status_mode = l:modelist
    return l:current_status_mode
endfunction

" Always show statusline
set laststatus=2

set showcmd

hi User1 ctermbg=237 ctermfg=white guibg=black guifg=white			" Regular
hi User2 ctermbg=blue   ctermfg=black  guibg=blue   guifg=black 	" Emphasis
hi User3 ctermbg=red  ctermfg=black guibg=red guifg=black			" LOOK NOW

set statusline=%1*\ 
set statusline+=%2*\ %{ModeCurrent()}\ 
set statusline+=%1*\ 
set statusline+=%f\ 
set statusline+=%m
set statusline+=%3*%r
set statusline+=%h
set statusline+=%w%1*

set statusline+=%=
set statusline+=%Y\ 

" fugitive git bindings
nnoremap <space>ga :Git add %:p<CR><CR>
nnoremap <space>gs :Gstatus<CR>
nnoremap <space>gc :Gcommit -v -q<CR>
nnoremap <space>gt :Gcommit -v -q %:p<CR>
nnoremap <space>gd :Gdiff<CR>
nnoremap <space>ge :Gedit<CR>
nnoremap <space>gr :Gread<CR>
nnoremap <space>gw :Gwrite<CR><CR>
nnoremap <space>gl :silent! Glog<CR>:bot copen<CR>
nnoremap <space>gp :Ggrep<Space>
nnoremap <space>gm :Gmove<Space>
nnoremap <space>gb :Git branch<Space>
nnoremap <space>go :Git checkout<Space>
nnoremap <space>gps :Dispatch! git push<CR>
nnoremap <space>gpl :Dispatch! git pull<CR>

" check file change every 4 seconds ('CursorHold') and reload the buffer upon detecting change
set autoread
au CursorHold * checktime

" relative numbers
set number relativenumber

" move commands (ctrl+shift+movement)
nnoremap <C-S-j> :m .+1<CR>==
nnoremap <C-S-k> :m .-2<CR>==
inoremap <C-S-j> <Esc>:m .+1<CR>==gi
inoremap <C-S-k> <Esc>:m .-2<CR>==gi
vnoremap <C-S-j> :m '>+1<CR>gv=gv
vnoremap <C-S-k> :m '<-2<CR>gv=gv
